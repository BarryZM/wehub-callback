{
  
  "0": {
    "title": "二维码登陆流程",
    "content": "由于目前的wehub必须通过人工操作来登陆,且每个wehub只能管理一个微信进程.若要运营大量的微信号,目前的方式必须远程/登陆到机器上进行大量的重复扫码登陆操作.这给自动化运行带来了大量不便.因此推出了二维码扫码登陆. . 二维码登陆流程 . 前提:当前机器上必须至少有一个已经登陆了的wehub进程(wehub_agent) . 1.新增新的任务类型task_type=200 任务数据格式为 . { &quot;task_type&quot;:200, &quot;task_dict&quot;: { &quot;qrcode_session_id&quot;: &quot;xxxxx&quot; //字符串,该值由第三方维护 } } . 2.回调接口向wehub_agent发送上述指令,让它拉起新的wehub进程(wehub_new). wehub_new会自动开启新的微信进程wechat_new并获取其二维码,通过文件上传接口进行form-data 方式的上传. form-data中包含:qr_session_id,file,machine_id三个字段 . Content-Type: multipart/form-data; boundary=&quot;boundary_.oOo._OTg2Ng==MzU3Mg==MjEwNzE=&quot; MIME-Version: 1.0 Content-Length: 46718 Connection: Keep-Alive Accept-Encoding: gzip, deflate Accept-Language: zh-CN,en,* User-Agent: Mozilla/5.0 --boundary_.oOo._OTg2Ng==MzU3Mg==MjEwNzE= Content-Type: text/plain Content-Disposition: form-data; name=&quot;qr_session_id&quot; xxxxxxxxxxxxxxxxxxxxx //这个值就是任务格式中qr_session_id字段的值 --boundary_.oOo._OTg2Ng==MzU3Mg==MjEwNzE= Content-Type: image/jpeg Content-Disposition: form-data; name=&quot;file&quot;;filename=&quot;xxxxx.png&quot; xxxxxxxxxxxxxxx..... //二维码图片的2进制字节流 xxxxxxxxxxxxxxx..... --boundary_.oOo._OTg2Ng==MzU3Mg==MjEwNzE= Content-Type: text/plain Content-Disposition: form-data; name=&quot;machine_id&quot; xxxxxxxxxxxx //login中也有machine_id,该字段可以用来区分不同的wehub进程 . 为什么需要有qr_session_id? 为了服务端好区分上传的二维码:二维码在一段时间没有被扫描的话会超时,超时以后微信客户端会重新请求新的二维码,wehub会重新上传新的二维码.服务端通过qr_session_id值就知道之前上传的二维码已经过期,用最新的二维码来代替之前旧的二维码. (服务端要建个map,记录qr_session_id和二维码的映射关系) . 3.上传的二维码被扫描成功后,wechat_new进程登陆成功,之后wehub_new进程会发送login request到服务端(格式见wehub的文档,但是login的data中会包含qr_session_id字段–普通方式的的login request不会有qr_session_id字段),一旦wehub_new进程登陆了,它也具备了拉起新的wehub进程的能力了. . 4.服务端在处理login时判断是否有qr_session_id字段,有的话就知道上传的二维码已经被扫描登陆了,从map中删除这个key. . 5.假如当前机器上有很多已登陆的wehub进程(和其管理的微信进程),这些wehub进程一旦logout了,由于不再会发任何数据给服务端,所以这些进程成为了’僵尸’进程.如何”回收”这些已经logout的wehub进程和wechat进程? . wehub对应的微信进程logout时,wehub会发logout通知给回调接口. 此时回调接口返回带特殊参数的的logout_acK,让wehub_son进程quit,并kill掉其管理的wechat_son微信进程. logout_acK格式为: . { &quot;error_code&quot;: 0, &quot;error_reason&quot;: &quot;&quot;, &quot;ack_type&quot;:&quot;logout_ack&quot;, &quot;data&quot;: { &quot;exit_wehub&quot;:1, //是否退出当前的wehub进程,0:否,1:是 &quot;exit_wechat&quot;:1 //是否kill控制的微信进程,0:否,1:是 } } . 测试方法 . 方法1:回调接口向wehub_agent下发任务来触发 . { &quot;task_type&quot;:200, &quot;task_dict&quot;: { &quot;qrcode_session_id&quot;: &quot;xxxxx&quot; //字符串,该值由第三方维护 } } . 方法2:手动通过命令行传参数的方式来触发 打开cmd,切换到wehub安装目录: cd C: Program Files (x86) WeHub 运行: wehub.exe –qr_session “test_session” .",
    "url": "http://localhost:3333/main/qrcode.html",
    "relUrl": "/main/qrcode.html"
  }
  ,"2": {
    "title": "接口文档",
    "content": "WeHub回调接口规范 . 目录 . 修改记录 | 概述 什么是appid? | 什么是wxid? | WeHub和第三方回调接口是如何通讯的? | 微信-wehub-回调接口 三者之间的数据流 | wxid与wx_alias | 获取当前微信帐号的wxid的方法 | wxid与wx_alias存在的多种形态 | . | 数据结构(request/respone) login(微信登录通知) 关于login_ack中flag_report_contact | . | logout(微信退出通知) | report_contact(上报当前好友列表和群列表) common_ack格式 | . | report_contact_update(上报成员信息变化) | report_room_member_info(上报群成员详细信息) | report_room_member_change(上报群成员变化) | report_new_room(上报新群) | report_new_msg(上报新的聊天消息) 上报的消息单元的格式$report_msgunit | . | 文件上传 | report_friend_add_request(新的加好友请求) | report_friend_removed(删除好友通知) | report_new_friend(新好友通知) | 任务类型格式$task 发消息任务类型的数据格式 | . | 上报僵死粉检测结果(report_zoom_check_status) | pull_task(向回调接口请求一个任务) | report_task_result(向回调接口反馈任务执行的结果) | report_user_info | . | 其他 容易混淆的地方 | 关于websocket的通讯方式 | . | . 修改记录 . 修改时间 对应的客户端版本 协议修改内容 . 2018.9.28 | v0.2.0 | 简化ack_type类型,”发消息任务”的字段有调整 | . 2018.10.12 | v0.2.2 | 回调地址改为到wehub后台网页里进行配置,增加secret key进行安全性验证 | . 2018.10.17 | v0.2.3 | login中增加”local_ip”字段 | . 2018.10.23 | v0.2.6 | 增加 report_contact_update ; userInfo 结构新增sex,country,province,city等字段 | . 2018.11.16 | v0.2.15 | login,logout中增加 machine_id 字段(起辅助作用);新增task_type 为14的任务类型 | . 2018.11.29 | v0.3.0 | 在report_contact 中增加对当前账号关注的公众号信息的上报;开始支持语音消息中的语音数据上传;支持下发扩展的gif表情任务 | . 2018.12.11 | v0.3.3 | 上报的文本消息中新增atuserlist字段;支持发文件消息中的文件数据上传;report_room_member_info有新增字段 | . 2018.12.27 | v0.3.6 | 客户端增加缓存清理设置(接口协议无修改) | . 2019.1.18 | v0.3.8 | 增加report_friend_removed | . 2019.3.15 | v0.4.0 | 客户端新增升级功能并强制在登陆时做安全验证. 新增检查僵尸粉的任务类型(task_type为15), report_contact_update 的userInfo 结构中新增is_friend字段. | . 2019.4.4 | v0.4.2 | 上报的个人微信号的信息中(城市,省份,国家等信息已准确),新增100,101两种本地打标签的任务类型. wehub已支持websocket方式的通讯(见文档最下方的描述).在发消息任务中增加at_style字段,可以把@符号放在文本中的任意位置 (见该任务类型的详细描述) | . 2019.8.14 | v0.4.6 | 新增了”查询个人号详情”的任务(task_type为16)和”创建新的群”的任务(task_type为17);新增report_user_info; report_new_msg上报的消息中新增了msg_id和msg_timestamp字段(分别代表消息的id和消息的时间戳) | . 2019.8.29 | v0.4.9 | login_ack增加option字段(服务端可自定义report_contact中上报的数据内容),新增task_type为18的任务类型 | . 2019.10.23 | v0.4.12 | 新增任务类型:接受入群邀请(task_type=19), 支持发送小程序 | . 概述 . 什么是appid? . appid是一段字符串,WeHub使用它来区分不同的第三方.任何想使用wehub服务的第三方首先向推宝科技申请, 申请时需提交自己的回调接口地址,推宝科技会对该地址做审核.第三方在使用WeHub时首先要在WeHub中 配置appid,WeHub验证通过后才会post数据到第三方的回调接口地址上. . 什么是wxid? . 就如同每个人都有一个身份证号一样,个人微信帐号/微信群都有唯一的标识字符串用来做区分 对于微信群,其格式为xxxxxx@chatroom(如8680025352@chatroom) 对于个人微信账号,其格式为wxid_xxxxxxx(以wxid_ 开头,如wxid_p9597egc5j1c21) 或者xxxxxxx(不以wxid_开头,在注册微信时由注册者自定义,如fangqing_hust) 本文档中所有数据结构中的”wxid”/”room_wxid”字段即代表个人微信账号/微信群号的唯一的标识字符串 | . WeHub和第三方回调接口是如何通讯的? . WeHub和回调接口之间采用http的方式进行通讯,双方都采用utf-8编码json格式的数据(Content-Type为application/json). 当微信中有相关的事件发生时,WeHub会主动post http request到回调接口,该http request中包含了解释具体微信事件的数据, 回调接口需返回适当的http respone,respone中包含下发给WeHub执行的任务(任务的格式见文档中描述) . 微信-wehub-回调接口 三者之间的数据流 . . wxid与wx_alias . 一个微信帐号典型的注册场景如下:你用手机号注册一个微信帐号,输入正确的手机验证码你的微信帐号就注册好了. 这个过程中你无法自定义微信号,注册成功后你的帐号显示的微信号格式为:wxid_xxxxx (这就是wxid,由微信系统按某种规则生成,不会重复不可更改,就如同一个人的身份证号),并且和你的手机号做了默认的绑定, 之后你每次登陆时输入手机号和短信验证码就可以正常登陆;后来你觉得每次用手机号登陆输入验证码的过程很繁琐, 并且那一长串wxid_xxxxxx很难记住(很多人记不住自己的身份证号码),于是你把你的微信号修改成一个让自己容易记 住并且彰显个性的别名比如spider_man(这就是wx_alias,由你自定义的,它也不会重复,类似你的电子邮箱地址) 之后你的微信号在微信客户端里显示为自定义的wx_alias,但无论是wxid还是wx_alias都能唯一标识你的这个微信账号. . 获取当前微信帐号的wxid的方法 . 方法1: 打开wehub客户端–&gt;设置界面–&gt;切换到”辅助设置”页,界面上会显示当前微信账号的wxid. 方法2: 打开微信客户端主界面,点击左上角头像,弹出的界面上显示”微信号:xxxxx”, 若是wxid_xxxx格式的,则该值为wxid,否则该值可能是自定义的帐号别名(wx_alias)而非wxid . wxid与wx_alias存在的多种形态 . 账号 wxid wx_alias 最终在微信客户端上展示的微信号 说明 . 个人号1 | wxid_7092880929211 | 空 | wxid_7092880929211 | 该帐号注册时用了微信默认提供的微信号,目前还没有自定义wx_alias,因此该账号还有1次自定义wx_alias的机会 | . 个人号2 | wxid_hrtv4z7etgvc22 | fangqing0827 | fangqing0827 | 该帐号注册时用了微信系统默认提供的微信号,后来又自定义wx_alias为fangqing0827(之后无法再次修改wx_alias) | . 个人号3 | fangqing_hust | 空 | fangqing_hust | 该帐号注册时用了自定义的微信号,所以没有机会自定义wx_alias了,因此wx_alias一直为空 | . 个人号4 | qq526552198 | heiheizwx | heiheizwx | 该帐号最初是用QQ注册的(现在已经不允许这种方式注册了),后来自定义了wx_alias为heiheizwx | . 公众号1 | gh_7ec28ec1ef37 | jueduixiao888 | jueduixiao888 | 普通的公众号wxid以gh开头 | . 公众号2 | Tencent-Games | 空 | Tencent-Games | 腾讯自家的公众号wxid不以gh_开头 | . 在微信app刚推出时,为了快速累积用户,允许用QQ账号来快速注册微信帐号,因此采用这种方式注册的微信帐号的wxid 为qqxxxxxxx格式(目前已无法用QQ号来注册微信账号),而用手机号注册的微信帐号的wxid为wxid_xxxxx格式. 每个帐号只有一次自定义别名的机会. 若一个微信帐号从没有自定义过其别名,则在客户端中展现的”微信号”的值(wx_number)就是该帐号的wxid,反之就是其wx_alias的值 . def getWxNumber(): if wx_alias is None: wx_number = wxid else wx_number = wx_alias return wx_number . 任何帐号,其wxid一定存在并且不为空,而wx_alias则可能为空.因此在wehub的数据结构中,统一用wxid来做参数进行各种操作. . . 数据结构(request/respone) . wehub发送的数据(简称为:request)json格式为: . { &quot;action&quot;: &quot;具体业务名&quot;, &quot;appid&quot;: &quot;第三方申请的id&quot;, &quot;wxid&quot;: &quot;当前登录的wxid&quot;, &quot;data&quot;: {具体业务的相关数据} } . wehub用”action”字段来区分发送的数据/事件的种类. 比如当前微信收到一条新消息时,wehub会发送action为”report_new_msg”的json数据, “data”中的数据为一条具体的消息(包含的消息发送者的wxid和消息的内容) 不同种类的action,对应的data的数据格式也不一样(接下来文档中会有详细描述) . 回调接口返回的数据(简称为:respone)json格式为: . { &quot;error_code&quot;: 0, //0代表没有错误,其他的第三方自定义 &quot;error_reason&quot;: &quot;&quot;, //如果出错,这里写出错原因的描述,否则留空 &quot;ack_type&quot;:&quot;xxxx_ack&quot;, //ack_type 字段不能缺失 &quot;data&quot;:{ xxxxx:xxxxxx //具体的附带的数据,不同的ack_type对应不同的data格式 } } 对于respone中带双引号的数据域,如果其语义为字符串,则双引号不可缺少 如:&quot;ack_type&quot;:&quot;login_ack&quot; ack_type字段其值代表具体的业务名称(字符串), 因此login_ack前后的&quot;&quot;符号不能省略 又如: &quot;error_code&quot;: 0, error_code其值语义为一个具体的错误码(数字),因此0前后不需要&quot;&quot;符号 . wehub发送的request 以utf-8编码,回调接口返回的respone 中的json格式数据 wehub 也以utf-8编码来解析 ,文档的示例代码中出现的 “$xxx” 符号代表这里应该出现一个名为”xxx”结构的数据对象,如 $task $report_msgunit等 . request中的action类型 respone中的ack_type . login | login_ack | . logout | logout_ack | . pull_task | pull_task_ack | . report_contact | common_ack | . report_contact_update | common_ack | . report_new_friend | common_ack | . report_new_msg | common_ack | . report_task_result | common_ack | . report_room_member_info | common_ack | . report_room_member_change | common_ack | . report_friend_add_request | common_ack | . report_new_room | common_ack | . report_friend_removed | common_ack | . report_zoom_check_status | common_ack | . report_user_info | common_ack | . 注:上述action中,回调接口必须实现对login的正确处理,否则使用相应appid的wehub 客户端将无法使用,对于其他不感兴趣/不想处理的action,可简单返回一个空的json{}.(总之收到wehub发送request后,回调接口必须有respone返回, 原因见Faq . login(微信登录通知) . 这是appid验证通过并且微信登陆后向回调接口发送的第一个request 回调接口必须对这个request做出正确的响应,否则wehub 会提示登陆失败/安全验证失败 . 自0.2.2版本开始,wehub引进了&quot;安全性验证&quot;机制. 第三方的管理员请登录WeHub后台 对回调参数进行配置, 系统会自动为每一个appID生成了&quot;secret key&quot;(该值用于之后的签名计算). . . WeHub的计费策略是每月按appid统计登陆wehub的微信号的数量, 因此登陆wehub的微信号数量直接影响第三方的wehub使用费用. 为了使登陆的微信号处于可控状态,第三方必须在服务端建立白名单,只允许白名单之内的微信号登陆. 在处理login请求时对白名单之外的微信号返回登陆失败,这样没有列入 白名单的微信号将无法登陆wehub,也不会计入当月的使用量. . 如何将我信任的微信号加入到白名单中? 点击该微信PC客户端左上方头像,将弹出的界面中显示的微信号的字符串值加入到的白名单中. | . . 回调接口在收到login时如何判断请求登陆微信帐号的合法性? | . . 我想添加群里其他人的微信号到我的白名单里,但是为何我看不到他们中某些人的微信号? 这是因为你与这些微信是陌生人关系.微信系统出于安全考虑,会对陌生人屏蔽微信号.加对方为好友后你就可以看到对方微信号了 | . login request格式为 . { &quot;action&quot; : &quot;login&quot;, //登录的业务名为&quot;login&quot; &quot;appid&quot;: &quot;xxxx&quot;, //申请的appid &quot;wxid&quot; : &quot;wxid_fo1039029348sfj&quot;, //当前登陆的微信账号的wxid &quot;data&quot; : { &quot;nickname&quot;: &quot;Bill&quot;, //微信昵称 &quot;wx_alias&quot;: &quot;mccbill&quot;, //自定义的微信别号(有可能为空) &quot;head_img&quot;: &quot;http://xxxxxx&quot;, //微信的头像地址 &quot;client_version&quot;:&quot;xxxxxx&quot; //wehub的版本号 &quot;nonce&quot;:&quot;xxxxxxxxxxxxxxx&quot; //回调接口在计算签名时用到这个nonce值 //有这个字段时服务端必须返回正确的签名 //没有这个字段时回调接口无需做签名处理 &quot;local_ip&quot;:&quot;192.168.0.104|211.168.0.104&quot; //当前wehub所在系统中的网卡ip,如有多个以&#39;|&#39;分隔, 该字段是在0.2.3 版本中新加入的 &quot;machine_id&quot;:&quot;xxxxxx&quot; //wehub客户端的标识(由计算机名+进程id生成)0.2.15版本中加入 } } . 回调接口返回(respone): . { &quot;error_code&quot;: 0, &quot;error_reason&quot;: &quot;&quot;, &quot;ack_type&quot;:&quot;login_ack&quot;, &quot;data&quot;:{ &quot;signature&quot;:&quot;xxxxxxxxxxx&quot; //返回给wehub客户端的签名 &quot;option&quot;:{ &quot;flag_report_contact&quot;: xxx //可选标志位(0.4.9 版本中新增) } } } 签名算法: 将login request中的wxid和nonce两个字段的值取出 然后将wxid,nonce,secretkey用&#39;#&#39;符号拼接成字符串,计算出md5值,该md5值的32位编码字符串即为签名值. 例如:wxid为&quot;fangqing_hust&quot;,nonce值为&quot;helloworld&quot;,secretkey为&quot;112233&quot;, 则signature = md5(&quot;fangqing_hust#helloworld#112233&quot;) = &quot;4B8D798F8B34A7BD2CD3B4CBFA309D9C&quot; 注意:返回的是md5值的32位字符串,不是16位的.(大写小写都可以) WeHub收到回调接口的login respone后 1.校验signature(若不通过弹框提示签名失败) 2.检查error_code的值.若不为0,则会弹框提示登陆失败及失败原因(从error_reason字段中取值) 通过以上检测后WeHub才算登陆成功(之后才会上报各种事件) . 关于login_ack中flag_report_contact . 若在report_contact中完整上报[好友+群+公众号]三者的数据会导致数据量太大/冗余,故新增该flag来设置只上报其中一部分关心的数据 . 值 含义 . 1 | 发送的report_contact中包含好友的信息(friend_list) | . 2 | 发送的report_contact中包含群的信息(group_list) | . 4 | 发送的report_contact中包含关注的公众号的信息(public_list) | . (flag_report_contact的值可以为上述选项其中一个或多个选项的数值相加后的结果) eg: 上报所有的信息 则值指定为7(1+2+4=7) . 1 :friend_list | 2 :group_list | 4 :public_list | . 如只上报好友和群的信息,则值指定为3(1+2=3) . 1 :friend_list | 2 :group_list | 4 :public_list | . 如只上报好友和公众号的信息,则值指定为5(1+4=5) . 1 :friend_list | 2 :group_list | 4 :public_list | . 如只上报群和公众号的信息,则值指定为6(2+4=6) . 1 :friend_list | 2 :group_list | 4 :public_list | . 如不上报任何信息,则值指定为0 . 1 :friend_list | 2 :group_list | 4 :public_list | . 从0.4.0版本开始,wehub客户端已强制要求做安全验证(无论后台是否取消了安全验证,request中都会有nonce 字段).对于服务端而言,只需判断受到的request中是否有nonce 字段, 有这个字段时服务端必须返回正确的签名!!! 没有这个字段时回调接口无需做签名处理(signature可以置空) . logout(微信退出通知) . request格式: . { &quot;action&quot;:&quot;logout&quot;, &quot;appid&quot;: &quot;xxxxxx&quot;, //申请的appid &quot;wxid&quot;: &quot;wxid_xxxxxxx&quot;, &quot;data&quot;:{ &quot;client_version&quot;:&quot;xxxxxx&quot; //wehub的版本号 &quot;machine_id&quot;:&quot;xxxxxx&quot; //wehub客户端的标识(由计算机名+进程id生成)0.2.15版本中加入 } } . respone格式 . { &quot;error_code&quot;: 0, &quot;error_reason&quot;: &quot;&quot;, &quot;ack_type&quot;:&quot;logout_ack&quot;, &quot;data&quot;:{} } . report_contact(上报当前好友列表和群列表) . WeHub在收到回调接口返回的login_ack之后,会做相关校验以验证登陆是否成功. 若登陆成功,会上报当前好友/群/公众号的信息, 如果微信的好友/群的数量比较多,这个request post的数据将会非常大. 别避免这种情况,在0.4.9中引进了flag_report_contact选项 由于微信客户端对联系人的信息加载是个lazy load 的过程,因此在report_contact 中上报的联系人信息可能不全, 比如有的头像信息没有获取到,wehub会通过 report_contact_update的方式进行增量更新,详情见[上报成员信息变化] report_contact 这个http请求Post的数据量会比较大(好友/群越多,post的数据就越大),请将服务端能接受的post_max_size 调整成至少10M . request格式 . { &quot;action&quot;: &quot;report_contact&quot;, &quot;appid&quot;: &quot;xxxxxx&quot;, &quot;wxid&quot;: &quot;wxid_xxxxxxx&quot;, &quot;data&quot;:{ &quot;friend_list&quot;:[$userInfo,$userInfo,$userInfo,...], //好友 &quot;group_list&quot;:[$groupinfo,$groupinfo, $groupinfo,......], //群 &quot;public_list&quot;:[$publicinfo,$publicinfo,$publicinfo,....] //公众号 } } data中相关字段描述 - groupinfo(群信息结构): { &quot;wxid&quot;: &quot;xxxxxxx&quot;, //群的wxid,格式为 xxxxx@chatroom &quot;name&quot;: &quot;xxxxxx&quot;, //群名称 &quot;owner_wxid&quot;: &quot;xxxxxxxx&quot;, //群主的wxid &quot;member_count&quot;: 100, //该群成员总数 &quot;head_img&quot;:&quot;http://xxxxxxxx&quot; //群的头像的url地址 &quot;member_wxid_list&quot; :[&#39;wxid_xxx1&#39;,&#39;wxid_xxx2&#39;,...] //当前群的成员wxid的列表 } - userInfo(好友信息结构) { &quot;wxid&quot;: &quot;wxid&quot;, //wxid &quot;wx_alias&quot;: &quot;xxxxx&quot;, //微信号(有可能为空) &quot;nickname&quot;:&quot;xxxxx&quot;, //微信昵称 &quot;remark_name&quot; :&quot;xxxx&quot;, //好友备注 &quot;head_img&quot;:&quot;http://xxxxxxxx&quot; //头像的url地址 &quot;sex&quot; : xx , //性别:1男，2女,0(未知) &quot;country&quot;:&quot;xxx&quot;, //祖国(可能为空) &quot;province&quot;:&quot;xxxx&quot;, //省份(可能为空) &quot;city&quot;:&quot;xxxxx&quot; //城市(可能为空) } - publicinfo(公众号信息) { &quot;wxid&quot;: &quot;gh_xxxxx&quot;, //某些公众号也可能以wxid_ 开头 &quot;nickname&quot;:&quot;xxxxx&quot;, //公众号名称 &quot;head_img&quot;:&quot;http://xxxxxxxxxx&quot; //头像 } . respone格式为:common_ack格式 . common_ack格式 . { &quot;error_code&quot;: 0, &quot;error_reason&quot;: &quot;&quot;, &quot;ack_type&quot;:&quot;common_ack&quot;, &quot;data&quot;:{ &quot;reply_task_list&quot;: [$task,$task,...] //回复的任务列表,如果没有要回复的任务,则列表为空 } } . 注:每个$task都是一个json对象,代表一个要下发给wehub执行的任务,格式见 [任务类型格式] . 示例 通过common_ack 向wehub回复两个任务,第一个任务让wehub向一个群发送3条消息(1条文本消息(同时@了两个群成员),1条图片消息,1条链接消息),第二个任务让wehub上报两个微信群的群成员信息 . { &quot;error_code&quot;: 0, &quot;error_reason&quot;: &quot;&quot;, &quot;ack_type&quot;:&quot;common_ack&quot;, &quot;data&quot;: { &quot;reply_task_list&quot;: [ { &quot;task_type&quot;: 1, &quot;task_dict&quot;: { &quot;wxid_to&quot;:&quot;wxid_test@chatroom&quot;, &quot;at_list&quot;:[&quot;wxid_b1&quot;,&quot;wxid_b2&quot;], &quot;msg_list&quot;: [ { &quot;msg_type&quot;:1, &quot;msg&quot;:&quot;自动回复,test&quot; }, { &quot;msg_type&quot;:3, &quot;msg&quot;:&quot;https://www.baidu.com/img/bd_logo1.png&quot; }, { &#39;msg_type&#39;:49, &#39;link_url&#39;:&quot;http://httpd.apache.org/&quot;, &quot;link_title&quot;:&quot;apache&quot;, &quot;link_desc&quot;:&quot;apache官网&quot;, &quot;link_img_url&quot;:&quot;http://httpd.apache.org/images/httpd_logo_wide_new.png&quot; } ] } }, { &quot;task_type&quot;:4, &quot;task_dict&quot;: { &quot;room_wxid_list&quot;:[&quot;wxid_test1@chatroom&quot;,&quot;wxid_test2@chatroom&quot;] } } ] } } . report_contact_update(上报成员信息变化) . 触发时机: wehub探测到联系人列表中的信息有更新(如昵称,头像等).”联系人”可能是我的好友,也可能是某个群里的成员,也可能是某个陌生人—总之这个联系人不表述好友关系); 亦或是在上报report_contact时尚未获取到的联系人/群信息. 为节省流量,wehub 会每隔10s检查这些变化,然后上传这些变化的信息. . request格式 . { &quot;action&quot;:&quot;report_contact_update&quot;, &quot;appid&quot;:&quot;xxxxxxxx&quot;, &quot;wxid&quot;:&quot;xxxxxxx&quot;, &quot;data&quot;:{ &quot;update_list&quot;:[ $userInfo,$groupbaseInfo,$userInfo,$groupbaseInfo,..... // 群基本信息(groupbaseInfo)和联系人信息(userInfo)的无序列表 // 如果其wxid字段以@chatroom结尾,其为groupbaseInfo // 否则代表联系人信息(userInfo) ] } } $userInfo - userInfo(好友信息结构) { &quot;wxid&quot;: &quot;wxid&quot;, //wxid &quot;wx_alias&quot;: &quot;xxxxx&quot;, //微信号(有可能为空) &quot;nickname&quot;:&quot;xxxxx&quot;, //微信昵称 &quot;remark_name&quot; :&quot;xxxx&quot;, //好友备注 &quot;head_img&quot;:&quot;http://xxxxxxxx&quot; //头像的url地址 &quot;sex&quot; : xx , //性别:1 男， 2 女 &quot;country&quot;:&quot;xxx&quot;, //祖国(可能为空) &quot;province&quot;:&quot;xxxx&quot;, //省份(可能为空) &quot;city&quot;:&quot;xxxxx&quot; //城市(可能为空) &#39;is_friend&#39;: x //0:不是我的好友;1:是我的好友 } $groupbaseInfo (群基本信息): { &quot;wxid&quot;: &quot;xxxxxxx&quot;, //群的wxid:格式为 xxxxx@chatroom &quot;name&quot;: &quot;xxxxxx&quot;, //群名称 &quot;head_img&quot;:&quot;http://xxxxxxxx&quot; //群头像的url地址 &quot;owner_wxid&quot;:&quot;xxxxxx&quot;, //群主的wxid,0.3.8版本中加入 &quot;member_count&quot;:xx //群成员总数,0.3.8版本中加入 } . respone格式为[common_ack格式] . report_room_member_info(上报群成员详细信息) . 触发时机: 由回调接口通过下发”任务”来被触发 . request { &quot;action&quot;:&quot;report_room_member_info&quot;, &quot;appid&quot;: &quot;xxxxxxxx&quot;, //申请的appid &quot;wxid&quot; : &quot;wxid_fo1039029348sfj&quot;, &quot;data&quot; : { room_data_list:[ { &quot;room_wxid&quot;:&quot;xxxxx1@chatroom&quot;, //群wxid &quot;name&quot;:&quot;xxxx&quot;, //群名(0.3.3版本中新增) &quot;owner_wxid&quot;:&quot;xxxxx&quot;, //群主wxid(0.3.3版本中新增) &quot;head_img&quot;:&quot;xxxxxxx&quot;, //群头像(0.3.3版本中新增) &quot;member_count&quot;: xxx, //群内有多少个成员(0.3.3版本中新增) &quot;memberInfo_list&quot;:[$memberInfo,$memberInfo.....] //群内成员信息 }, ........ ] } } $memberInfo 结构如下: { &quot;wxid&quot;: &quot;wxid&quot;, //wxid &quot;wx_alias&quot;: &quot;xxxxx&quot;, //微信号(有可能为空) &quot;room_nickname&quot;: //这个微信号的群昵称 &quot;nickname&quot;:&quot;xxxxx&quot;, //微信昵称 &quot;head_img&quot;:&quot;http://xxxxxxxx&quot; //头像的url地址 &quot;sex&quot;:xx, //0未知,1 男， 2 女 &quot;country&quot;:&quot;xxx&quot;, &quot;province&quot;:&quot;xxx&quot;, &quot;city&quot;:&quot;xxx&quot; } . respone格式为[common_ack格式] . report_room_member_change(上报群成员变化) . 触发时机:群成员增加或减少时上报 . request { &quot;action&quot;:&quot;report_room_member_change&quot;, &quot;appid&quot;:&quot;xxxxxxx&quot;, &quot;wxid&quot;: &quot;wxid_xxxxxxx&quot;, &quot;data&quot;:{ &quot;room_wxid&quot;:&quot;xxxxxxx@chatroom&quot;, &quot;owner_wxid&quot;:&quot;xxxxx&quot;, //群主wxid, 0.3.8版本中加入 &quot;wxid_list&quot;;[&quot;xxxxxx&quot;,&quot;xxxxx&quot;], //变化的成员的wxid列表 &quot;flag&quot;: flag //0,群成员减少;1,群成员增加 } } . respone格式为[common_ack格式] . report_new_room(上报新群) . 触发时机:当发现新的群时(比如被拉进了新的群或新建了新的群) . request { &quot;action&quot;:&quot;report_new_room&quot;, &quot;appid&quot;:&quot;xxxxxxx&quot;, &quot;wxid&quot;: &quot;wxid_xxxxxxx&quot;, &quot;data&quot;:{ &quot;wxid&quot;:&quot;xxxxx&quot;, //新群的wxid &quot;name:&quot;xxxx&quot;, //群名(可能为空) &quot;owner_wxid&quot;:&quot;xxxxx&quot;, //群主的wxid &quot;head_img&quot;:&quot;xxxx&quot;, //群头像的url地址 &quot;memberInfo_list&quot;:[$memberInfo,$memberInfo,.....] //见memberInfo结构 } } $memberInfo结构如下 { &quot;wxid&quot;: &quot;wxid&quot;, //wxid &quot;wx_alias&quot;: &quot;xxxxx&quot;, //微信号(有可能为空) &quot;room_nickname&quot;: //这个微信号的群昵称 &quot;nickname&quot;:&quot;xxxxx&quot;, //微信昵称 &quot;head_img&quot;:&quot;http://xxxxxxxx&quot; //头像的url地址 } . respone格式为[common_ack格式] . report_new_msg(上报新的聊天消息) . 触发时机:当收到私聊消息或所在的某个群内有人发言(含自己发送的消息) . 对于做了自动回复功能的第三方接口,需要过滤自己发的消息.否则会陷入”回调接口下发自动回复–&gt;wehub发消息—&gt;微信消息事件回调—&gt;wehub上报刚才自己发的消息—&gt;回调接口又下发聊天任务”的死循环 . 一旦陷入死循环,容易导致wehub高频率地发消息,这极易触发微信系统的安全提醒甚至被封号 如何过滤自己发的消息? 若使用的wehub版本&lt;0.1.4,回调接口在收到report_new_msg时,判断msg中的wxid是否为这个wehub上登陆的wxid. 若是,则不要下发task_type=1的发消息的任务 若使用的wehub版本&gt;=0.1.4,回调接口在收到report_new_msg时,判断msg中的wxid_from是否为这个wehub上登陆的wxid.若是,则不要下发task_type=1的发消息的任务 . request { &quot;action&quot; : &quot;report_new_msg&quot;, &quot;appid&quot;: &quot;xxxxxxxx&quot;, //申请的appid &quot;wxid&quot; : &quot;wxid_fo1039029348sfj&quot;, &quot;data&quot; : { &quot;msg&quot;: $report_msgunit //上报单条消息 //report_msgunit格式见[上报的消息单元的格式] } } . respone格式为[common_ack格式] . 上报的消息单元的格式$report_msgunit . 聊天消息类型 类型值msg_type 是否支持任务下发 是否支持上传消息中的文件 . 文本消息 | 1 | 支持 | —- | . 图片消息 | 3 | 支持 | 支持消息中的图片文件上传 | . 个人名片 | 42 | 支持 | —- | . 语音 | 34 | 暂不支持 | 从0.3.0版本开始支持 | . 视频 | 43 | 支持 | 支持消息中的视频文件上传 | . 表情消息 | 47 | 从0.3.0版本开始支持 | 不支持 | . 链接消息 | 49 | 支持 | —- | . 小程序 | 4901 | 0.4.12开始支持 | —- | . 转账 | 4902 | 暂不支持 | —- | . 文件 | 4903 | 暂不支持 | 暂不支持 | . 微信系统通知 | 10000 | 不支持 | —- | . - 文本消息 { &quot;msg_id&quot;: &quot;xxxxx&quot; //消息id(字符串) &quot;msg_timestamp&quot;: xxxxxx, //消息的时间戳(单位为毫秒) &quot;msg_type&quot;: 1, //1 代表文本消息 &quot;room_wxid&quot;: &quot;xxxxxxxx@chatroom&quot;, //聊天消息发生在哪个群(如果是私聊则为空) &quot;wxid_from&quot;: &quot;wxid_xxxxxx&quot;, //消息发送者的wxid //如果是自己发的消息这里的wxid就是自己的微信号 &quot;wxid_to&quot;: &quot;wxid_xxxxx&quot;, //消息的接收者的wxid //如果发往群的消息,这个值就是群的wxid //如果是别人私聊给自己的消息,这里就是自己的微信号 &quot;atUserList&quot;: [&quot;xxx&quot;,&quot;xxx&quot;] //这条消息@的对象列表 &quot;msg&quot;: &quot;xxxxxxxx&quot; //具体的文本内容 //如果A在群里面at了B(群昵称为BN),C(群昵称为CN),则msg的格式为&quot;@BN @CN XXXXXX&quot; (@BN @CN之间有空格) } 例如: A用户在B群里发了一条消息: &quot;room_wxid&quot;: &quot;B群wxid&quot;, &quot;wxid_from&quot;:&quot;A的wxid&quot;, &quot;wxid_to&quot;: &quot;B群wxid&quot;, A给我私聊了一条消息: &quot;room_wxid&quot;: &quot;&quot;, &quot;wxid_from&quot;:&quot;A的wxid&quot;, &quot;wxid_to&quot;: &quot;我的wxid&quot;, 我在B群里发了一条消息: &quot;room_wxid&quot;: &quot;B群wxid&quot;, &quot;wxid_from&quot;:&quot;我的wxid&quot;, &quot;wxid_to&quot;: &quot;B群wxid&quot;, 我向A发了一条私聊消息: &quot;room_wxid&quot;: &quot;&quot;, &quot;wxid_from&quot;:&quot;我的wxid&quot;, &quot;wxid_to&quot;: &quot;A的wxid&quot;, - 图片消息 { &quot;msg_id&quot;: &quot;xxxxx&quot;, //消息id(字符串) &quot;msg_timestamp&quot;: xxxxxx, //消息时间戳(单位为毫秒) &quot;msg_type&quot;: 3, //3 代表图片消息 &quot;room_wxid&quot;: &quot;xxxxxxxx@chatroom&quot;, //同文本消息 &quot;wxid_from&quot;: &quot;wxid_xxxxxx&quot;, //同文本消息 &quot;wxid_to&quot;: &quot;wxid_xxxxx&quot;, //同文本消息 &quot;file_index&quot;:&quot;xxxxxx&quot; //图片文件的唯一索引(由wehub生成) //该字段在wehub上报消息时有效 //如果是自己发/转发的图片,file_index为本地的文件路径 } - 链接消息 (可能是一个入群的链接,也可能是一个分享的网页的链接) { &quot;msg_id&quot;: &quot;xxxxx&quot;, &quot;msg_timestamp&quot;: xxxxxx, &quot;msg_type&quot;:49, //49 代表链接消息 &quot;room_wxid&quot;: &quot;xxxxxxxx@chatroom&quot;, &quot;wxid_from&quot;: &quot;wxid_xxxxxx&quot;, &quot;wxid_to&quot;: &quot;wxid_xxxxxx&quot;, &quot;link_title&quot;:&quot;标题&quot;, //链接标题 &quot;link_desc&quot;: &quot;副标题&quot;, //链接描述（副标题） &quot;link_url&quot;:&quot;http://xxxxx&quot;, //链接的url &quot;link_img_url&quot;: &quot;http://xxxxxxx&quot;, //链接的缩略图的的Url,jpg或者png格式 &quot;sub_type&quot;: x, //链接消息的子类型(0.4.12版本中新增) //当值为5时并且link_url的值是以这种格式开头: //&quot;https://support.weixin.qq.com/cgi-bin/mmsupport-bin/addchatroombyinvite?ticket=xxxxxx时&quot; //该链接消息是一个入群邀请链接(每个入群链接的ticket参数不一样,见任务类型:接收进群邀请) //入群邀请链接只在一段时间内有效,过期后将无法进入被邀请的群 &quot;raw_msg&quot;: &quot;xxxxxxx&quot; //微信的原始消息,xml格式,0.3.14版本中新增 } raw_msg 中的关键字段有&quot;title&quot;,&quot;des&quot;,&quot;url&quot;,&quot;thumburl&quot;(分别与link_title,link_desc,link_url,link_img_url值对应), 如果link_url值为空,请自行分析raw_msg中的url. - 表情消息 { &quot;msg_id&quot;: &quot;xxxxx&quot;, &quot;msg_timestamp&quot;: xxxxxx, &quot;msg_type&quot;:47, &quot;room_wxid&quot;: &quot;xxxxxxxx@chatroom&quot;, &quot;wxid_from&quot;: &quot;wxid_xxxxxx&quot;, &quot;wxid_to&quot;: &quot;wxid_xxxxxx&quot;, &quot;emoji_url&quot;: &quot;xxxxxxxxx&quot; //表情的url地址(若有需要,请回调接口自行下载该文件) &quot;raw_msg&quot;: &quot;xxxxxxx&quot; } - 小程序 { &quot;msg_id&quot;: &quot;xxxxx&quot;, &quot;msg_timestamp&quot;: xxxxxx, &quot;msg_type&quot;:4901, &quot;room_wxid&quot;: &quot;xxxxxxxx@chatroom&quot;, &quot;wxid_from&quot;: &quot;wxid_xxxxxx&quot;, &quot;wxid_to&quot;: &quot;wxid_xxxxxx&quot;, &quot;raw_msg&quot;: &quot;xxxxxxx&quot; //微信中的小程序信息的原始数据,xml格式,请自行解析 &quot;file_index&quot;: xxxxxxxxxxx //小程序的封面的文件索引, 0.4.12新增 (如果需要转发这个小程序的话,该封面需先上传到第三方的服务器上) } - 转账事件 触发时机: 情况一:我转账给他人 1.发起转账时:wxid_from=&#39;我的wxid&#39;,wxid_to=&#39;他人的wxid&#39;,paysubtype=1 2.对方确认收账时:wxid_from =&#39;他人的wxid&#39;,wxid_to=&#39;我的wxid&#39;,paysubtype=3 情况二:他人转账给我: 1.发起转账时:wxid_from =&#39;他人的wxid&#39;,wxid_to=&#39;我的wxid&#39;,paysubtype=1 (只有这种情况下才能自动收账,格式见自动收账任务) 2.我确认收账时:wxid_from=&#39;我的wxid&#39;,wxid_to=&#39;他人的wxid&#39;,paysubtype=3 { &quot;msg_id&quot;: &quot;xxxxx&quot;, &quot;msg_timestamp&quot;: xxxxxx, &quot;msg_type&quot;:4902, &quot;wxid_from&quot;: &quot;wxid_xxxxxx&quot;, &quot;wxid_to&quot;: &quot;wxid_xxxxxx&quot;, &quot;transferid&quot;: &quot;xxxxxxx&quot; //转账的ID &quot;paysubtype&quot;:paysubtype, //这笔账单的状态 &quot;raw_msg&quot;: &quot;xxxxxxx&quot; //微信中的转账事件的原始数据,xml格式 } - 文件 (从0.3.3版本开始支持文件上传) { &quot;msg_id&quot;: &quot;xxxxx&quot; &quot;msg_timestamp&quot;: xxxxxx, &quot;msg_type&quot;:4903, &quot;room_wxid&quot;: &quot;xxxxxxxx@chatroom&quot;, //发生在哪个群里 &quot;wxid_from&quot;: &quot;wxid_xxxxxx&quot;, //文件发送者 &quot;wxid_to&quot;:&quot;wxid_xxxxx&quot;, //文件接收者 &quot;file_index&quot;:&quot;xxxxx&quot;, &quot;file_name&quot;: &quot;xxxxxx&quot;, //文件名 &quot;file_size&quot;: xxxxx, //字节数 &quot;raw_msg&quot;: &quot;xxxxxxx&quot; //微信中的文件的原始消息,xml格式,请自行解析 } - 个人名片 { &quot;msg_id&quot;: &quot;xxxxx&quot;, &quot;msg_timestamp&quot;: xxxxxx, &quot;msg_type&quot;:42, &quot;room_wxid&quot;: &quot;xxxxxxxx@chatroom&quot;, &quot;wxid_from&quot;: &quot;wxid_xxxxxx&quot;, &quot;wxid_to&quot;: &quot;wxid_xxxxxx&quot;, &quot;raw_msg&quot;: &quot;xxxxxxx&quot; //微信中的名片信息的原始数据,xml格式,请自行解析 } - 语音消息 (从0.3.0版本开始支持上传消息中的语音文件,将微信中原始语音数据转化为MP3格式后上报) { &quot;msg_id&quot;: &quot;xxxxx&quot;, &quot;msg_timestamp&quot;: xxxxxx, &quot;msg_type&quot;:34, &quot;room_wxid&quot;: &quot;xxxxxxxx@chatroom&quot;, &quot;wxid_from&quot;: &quot;wxid_xxxxxx&quot;, &quot;wxid_to&quot;: &quot;wxid_xxxxxx&quot;, &quot;file_index&quot;:&quot;xxxxxxx&quot;,//0.3.0之前的版本中该值都预留为空 &quot;raw_msg&quot;: &quot;xxxxxxx&quot; //微信中的原始消息,xml格式 } - 视频消息 { &quot;msg_id&quot;: &quot;xxxxx&quot;, &quot;msg_timestamp&quot;: xxxxxx, &quot;msg_type&quot;:43, &quot;room_wxid&quot;: &quot;xxxxxxxx@chatroom&quot;, &quot;wxid_from&quot;: &quot;wxid_xxxxxx&quot;, &quot;wxid_to&quot;: &quot;wxid_xxxxxx&quot;, &quot;file_index&quot;:&quot;xxxxxx&quot;, //视频文件的索引 &quot;raw_msg&quot;:&quot;xxxxxxx&quot;, //视频文件详细信息(文件大小length,播放时长playlength),需服务端自行解析;可根据文件大小来判断是否要上传 } - 微信系统通知 { &quot;msg_id&quot;: &quot;xxxxx&quot;, &quot;msg_timestamp&quot;: xxxxxx, &quot;msg_type&quot;:10000, &quot;room_wxid&quot;: &quot;xxxxxxxx@chatroom&quot;, &quot;wxid_from&quot;: &quot;wxid_xxxxxx&quot;, &quot;wxid_to&quot;: &quot;wxid_xxxxxx&quot;, &quot;raw_msg&quot;: &quot;xxxxxxxx&quot; //具体的通知内容,纯文本格式 } 无需对系统通知做自动回复 eg: 1.发消息-被对方拉黑之后,raw_msg 为&quot;消息已发出，但被对方拒收了&quot; 2.有红包出没时:&quot;发出红包，请在手机上查看&quot; 3.修改群名称后:xxxxx修改群名为xxxxxxx 其他: 群主已恢复默认进群方式。 群主已启用“群聊邀请确认”，群成员需群主确认才能邀请朋友进群。 你已成为新群主 xxxxxx已成为新群主 你邀请xxxx加入了群聊 xxxx邀请xxxx加入了群聊 xxxxx通过扫描你分享的二维码加入群聊&quot; xxxxx通过扫描xxxxxx分享的二维码加入群聊&quot; . 文件上传 . 在WeHub后台配置文件上传的接口地址,WeHub会将需要上传的文件(比如聊天消息中的图片,语音,视频等)数据post到该地址上(form-data方式). . 基本流程: 1.wehub收到图片消息/视频消息,上报基本信息(此时wehub仅仅通过report_new_msg上报该图片的索引file_index值,不上传具体文件的二进制信息) 2.回调接口根据file_index的值查询当前服务端文件存储系统中是否已经存在该索引的文件,若需要wehub上传,在ack中携带上传文件的任务类型: 比如 { &quot;error_code&quot;: 0, &quot;error_reason&quot;: &quot;&quot;, &quot;ack_type&quot;:&quot;common_ack&quot;, &quot;data&quot;: { &quot;reply_task_list&quot;: [ { &quot;task_type&quot;: 9, &quot;task_dict&quot;: { &quot;file_index&quot;:&quot;xxxxxxx&quot; } } ] } } 3.wehub收到指令后通过文件上传接口上传文件(post 方式) 4.上传接口返回文件处理的结果 { &#39;error_code&#39;:0, &#39;error_reason&#39;:&#39;&#39;, &#39;ack_type&#39;:&#39;upload_file_ack&#39;, &#39;file_index&#39;:file_index //接收到的文件的file_index } . 以下为 wehub向上传接口上传图片文件的http request示例(Content-Type: multipart/form-data) . Content-Type: multipart/form-data; boundary=&quot;boundary_.oOo._OTg2Ng==MzU3Mg==MjEwNzE=&quot; MIME-Version: 1.0 Content-Length: 46718 Connection: Keep-Alive Accept-Encoding: gzip, deflate Accept-Language: zh-CN,en,* User-Agent: Mozilla/5.0 Host: localhost.:5678 --boundary_.oOo._OTg2Ng==MzU3Mg==MjEwNzE= Content-Type: text/plain Content-Disposition: form-data; name=&quot;file_index&quot; 3053020100044c304a02010002041cdc709b02032f56c10204a2e5e77302045b87dcfa0425617570696d675f356665376666383735333737623337355f313533353633303538353633390204010400020201000400 --boundary_.oOo._OTg2Ng==MzU3Mg==MjEwNzE= Content-Type: image/jpeg Content-Disposition: form-data; name=&quot;file&quot;;filename=&quot;6a0b2e8d81857cd9ac7cf4fcb6ac271fd409fc1d.jpg&quot; xxxxxxxxxxxxxxx..... //图片的二进制字节流 xxxxxxxxxxxxxxx..... . 上传视频 . Content-Type: multipart/form-data; boundary=&quot;boundary_.oOo._MTQ5NDU=Mjg1Nzk=MTAyNzE=&quot; MIME-Version: 1.0 Content-Length: 1351338 Connection: Keep-Alive Accept-Encoding: gzip, deflate Accept-Language: zh-CN,en,* User-Agent: Mozilla/5.0 Host: localhost.:5678 --boundary_.oOo._MTQ5NDU=Mjg1Nzk=MTAyNzE= Content-Type: text/plain Content-Disposition: form-data; name=&quot;file_index&quot; 306b0201000464306202010002041cdc709b02032f56c10204cde5e77302045b99fc32043d617570766964656f5f356665376666383735333737623337355f313533363831383232345f3137353730343133303931383637613066633434323433300204010400040201000400 --boundary_.oOo._MTQ5NDU=Mjg1Nzk=MTAyNzE= Content-Type: video/mp4 Content-Disposition: form-data; name=&quot;file&quot;;filename=&quot;c899cebad9877280af73d4e595f5d1e41e7b1ed8.mp4&quot; xxxxxxxxxxxxxxx..... //视频文件的二进制字节流 xxxxxxxxxxxxxxx..... . 上传语音 . Content-Type: multipart/form-data; boundary=&quot;boundary_.oOo._NDM2NQ==NTkyNQ==MzE1ODQ=&quot; MIME-Version: 1.0 Content-Length: 2993 Connection: Keep-Alive Accept-Encoding: gzip, deflate Accept-Language: zh-CN,en,* User-Agent: Mozilla/5.0 Host: localhost.:5678 --boundary_.oOo._NDM2NQ==NTkyNQ==MzE1ODQ= Content-Type: text/plain Content-Disposition: form-data; name=&quot;file_index&quot; 4166303733643135323139616165340028224211291867a0fc48766102 --boundary_.oOo._NDM2NQ==NTkyNQ==MzE1ODQ= Content-Type: audio/mpeg Content-Disposition: form-data; name=&quot;file&quot;;filename=&quot;274cfbce78d88c83a9d0bd7d0cda9fe3c2da2d64.mp3&quot; xxxxxxxxxxxxxxx..... //mp3文件的二进制字节流 xxxxxxxxxxxxxxx..... . 注意: 1.服务端的上传接口接收到wehub的request后需要取出 request中 file_index的值. 2.目前wehub支持上传图片/视频类型的文件,但wehub的文件上传功能并不是一个完全可靠的服务,当微信中的图片/视频没有下载完成时,wehub是无法上传这些文件的. . report_friend_add_request(新的加好友请求) . 收到添加好友的请求(此时对方还不是我的好友,不能给对方发消息) 微信系统对每个账号每天通过的好友请求有限制(每天200左右) 服务端需要储存(v1,v2) 值, 以便通过任务下发的方式通过好友验证 . request { &quot;action&quot; : &quot;report_friend_add_request&quot;, &quot;appid&quot;: &quot;xxxxxxx&quot;, &quot;wxid&quot; : &quot;wxid_fo1039029348sfj&quot;, &quot;data&quot; : { &quot;v1&quot;:&quot;xxxxxx&quot;, //若要自动通过,请在ack中回传 &quot;v2&quot;:&quot;xxxxxxx&quot;, //若要自动通过,请在ack中回传 &quot;notice_word&quot;:&quot;xxxxxxx&quot;, //新好友加我时的打招呼的内容,可能为空 &quot;raw_msg&quot;:&quot;xxxxxxxxxxx&quot; //微信中的原始消息,xml格式 } } 若要自动通过好友验证,可在reply_task_list字段中加入&quot;通过好友验证&quot;的任务(task_type为13) . respone格式为[common_ack格式] . report_friend_removed(删除好友通知) . 当某个好友被删除了会上报该事件 . request格式 { &quot;action&quot;:&quot;report_friend_removed&quot;, &quot;appid&quot;: &quot;xxxxxxx&quot;, &quot;wxid&quot;: &quot;xxxxxxx&quot;, &quot;data&quot;:{ &quot;wxid_removed&quot;:&quot;xxxxxx&quot; //被删除的好友的wxid } } . respone格式为[common_ack格式] . report_new_friend(新好友通知) . 每当有新的好友时,上报新好友的个人信息(此时对方已经成为了我的好友) . request格式 { &quot;action&quot; : &quot;report_new_friend&quot;, &quot;appid&quot;: &quot;xxxxxxx&quot;, &quot;wxid&quot; : &quot;xxxxxx&quot;, &quot;data&quot; : { &quot;fans_wxid&quot;: &quot;wxid_ljsdlfjslfjl&quot;, // 新好友的wxid &quot;nickname&quot;: &quot;Jerry&quot;, // 新好友的昵称 &quot;wx_alias&quot;: &quot;jerry&quot; // 新好友的微信号,可能为空 &quot;head_img&quot;: &quot;xxxxx&quot;, //头像url &quot;notice_word&quot;: &quot;xxxxxxx&quot; //新好友加我时的打招呼的内容,可能为空 &quot;sourceusername&quot;: &quot;xxxxx&quot; //推荐人的wxid,可能为空 &quot;sourcenickname&quot;:&quot;xxxxxxx&quot; //推荐人昵称,可能为空 } } . respone格式为[common_ack格式] . 任务类型格式$task . 回调接口在 respone中下发的任务格式 . 任务类型 类型值task_type . 发消息 | 1(只支持文字,图片,链接,视频,个人名片) | . 踢人 | 2 | . 邀请入群(发送入群邀请) | 3 | . 上报群成员信息 | 4 | . 加群成员为好友 | 5 | . 修改好友备注 | 6 | . 修改群昵称 | 7 | . 退群 | 8 | . 上传文件 | 9 | . 发群公告 | 10 | . 自动收账 | 11 | . 删除好友 | 12 | . 通过好友验证 | 13 | . 重新上报当前好友列表和群列表 | 14 | . 检测某个wxid是否是僵尸 | 15 | . 获取指定wxid的详情 | 16 | . 创建群 | 17 | . 修改群名称 | 18 | . 接受入群邀请 | 19 | . 文本消息中静态表情转义对照表 . 当你在微信中发送一个的静态的表情时,其实你只是发送了 “[笑脸]” 这几个文字 . 发消息任务类型的数据格式 . (向一个微信群或一个微信号发一组消息单元) { &quot;task_type&quot;: 1, &quot;task_dict&quot;: { &quot;wxid_to&quot;:&quot;xxxxxx&quot;, //消息发往的对象(群微信号或者个人微信号) &quot;at_list&quot;:[&#39;xxxx&#39;,&#39;xxxx&#39;], //发群消息时,需要@的对象的wxid列表,可以为空 //at_list对msg_list里所有的文本消息生效 &quot;msg_list&quot;:[$push_msgunit,$push_msgunit,....] //待发送的消息单元列表 &quot;at_style&quot;: xx //0或者1, 默认为0. 该字段在0.4.2中新增. } } 发消息任务中的$push_msgunit格式 ⑴文字消息 { &#39;msg_type&#39;:1, &#39;msg&#39;: &quot;xxxxxx&quot; 发送的文字(可以嵌入转义的静态表情文字,参阅上方的链接 静态表情转义对照表) } 关于@符号的位置 ⑵图片消息 { &#39;msg_type&#39;:3, &#39;msg&#39;:&quot;xxxx&quot; //图片的url绝对地址:http://xxxxxxx/xx.jpg或png } ⑶gif表情 //从0.3.0开始支持 { &quot;msg_type&quot;:47, &quot;msg&quot;:&quot;http://xxxxxxx/xx.gif&quot; //gif的url:必须是gif格式 } ⑷链接消息 { &quot;msg_type&quot;:49, //49 代表链接消息 &quot;link_url&quot;:&quot;http://xxxxx&quot;, //分享链接的url &quot;link_title&quot;:&quot;标题&quot;, //链接标题 &quot;link_desc&quot;: &quot;副标题&quot;, //链接描述（副标题） &quot;link_img_url&quot;: &quot;http://xxxxxxx&quot; //链接的缩略图的的Url,jpg或者png格式 } ⑸视频消息/文件消息 { &quot;msg_type&quot;:43, &quot;video_url&quot;:&quot;http://xxxxxxx/xx.mp4&quot; //回调接口推送给用户的视频的url地址, mp4格式 } 注:如果要发任意文件(文件格式无限制),将video_url的值换成要发送的文件的url的地址即可. 例如若video_url设为 https://archive.apache.org/dist/httpd/docs/httpd-docs-2.4.16.en.pdf 即可将该pdf文件发送给对方. ⑹语音消息 暂时无法支持发送语音消息 ⑺个人名片 { &quot;msg_type&quot;:42, &quot;wxid_card&quot;:&quot;xxxxxx&quot; //个人号/公众号的wxid } ⑻发小程序 //前提:wehub所管理的微信客户端必须支持小程序 { &quot;msg_type&quot;:4901, &quot;raw_msg&quot;:&quot;xxxxxxxx&quot;, //小程序的raw_msg是一串xml格式的文本 [见&quot;上报的消息单元&quot;--&gt;&quot;小程序&quot;中的raw_msg字段] //服务端可以存储这个raw_msg(不要做任何修改,这很重要!!!)之后用于小程序转发 &quot;cover_url&quot;: &quot;http://xxxxxxxx&quot; //小程序的封面图片的的url //请保证url有效能被正常下载,否则转发的小程序接受者将看不到封面 } . 关于’@’符号的位置 . 只针对发往群的文本消息有效 在0.4.2版本之前,wehub是默认把@符号放在文本消息的最前面的. 从0.4.2版本开始,支持把&#39;@&#39;放在文本消息的任意位置,具体操作如下: 1.发消息任务中的at_style字段设置为1 2.文本消息的msg的内容中设置占位字符串 {$@},这些字符的位置就是最终的@符号所在的位置 { &quot;task_type&quot;: 1, &quot;task_dict&quot;: { &quot;wxid_to&quot;:&quot;xxxxxx&quot;, &quot;at_list&quot;:[&quot;wxid_a&quot;,&quot;wxid_b&quot;], //假设这两个被@的微信号的群昵称分别为aa,bb &quot;msg_list&quot;:[ { &#39;msg_type&#39;:1, &#39;msg&#39;:&quot;test,你好{$@},你好{$@}.早上好&quot; } ] &quot;at_style&quot;: 1 //注意这里必须为1. } } 则wehub收到后,则实际发送的内容为 &quot;test,你好@ aa,你好@ bb.早上好&quot;(占位符被替换了) 注意at_list不能为空,at_style必须为1,占位字符串的数量必须和at_list中的微信数量相等. 当at_style为0时仍然按照以往的方式(@符号放在文本最前面,此时发送文本总即使有{$@}占位符wehub也不会进行替换)进行发送 . - 踢人任务: (把一个微信号从指定的群踢出,当前微信必须有踢人权限(为群主或者群管理员)) { &quot;task_type&quot;:2, &quot;task_dict&quot;: { &quot;room_wxid&quot;:&quot;xxxxx@chatroom&quot;, //被踢者所在的群,如果为空,则从所有的群踢出 &quot;wxid&quot;:&quot;xxxxxxx&quot; //被踢者的wxid } } . - 拉群任务: (向一个好友发入群邀请,注意必须是自己的好友) { &quot;task_type&quot;:3, &quot;task_dict&quot;: { &quot;room_wxid&quot;:&quot;xxxxx@chatroom&quot;, //目标群 &quot;wxid&quot;:&quot;xxxxxxx&quot; //被拉进群的wxid &quot;flag&quot;:x //0.4.12新增. //默认为0:向好友发入群邀请链接 //值为1:不发入群邀请链接,而是直接将好友拉到群里(当群人数超过40时,该方法会失败) } } - 上报群成员信息: (上报某个群里所有的群成员的详细信息,如果群成员比较多,上报的数据量会比较大) { &quot;task_type&quot;:4, &quot;task_dict&quot;: { //要上报的群列表 &quot;room_wxid_list&quot;:[&quot;xxxxx@chatroom&quot;,&quot;xxxxx2@chatroom&quot;....] } } wehub 通过report_room_member_info来主动上报,详情见[上报群成员详细信息] - 加群成员为好友： { &quot;task_type&quot;:5, &quot;task_dict&quot;: { &quot;room_wxid&quot;:&quot;xxxxx@chatroom&quot;, //群wxid,可以留空 &quot;wxid&quot;:&quot;xxxxxxx&quot; //要加谁为好友,不能为空 &quot;msg&quot;:&quot;xxxxxx&quot; //打招呼消息,文本 } } - 修改好友备注: { &quot;task_type&quot;:6, &quot;task_dict&quot;: { &quot;wxid&quot;:&quot;xxxxxx&quot;, //好友微信 &quot;remark_name&quot;:&quot;xxxxxx&quot; //好友备注 } } - 修改群昵称: (修改当前微信号在某个群里的群昵称) { &quot;task_type&quot;:7, &quot;task_dict&quot;: { &quot;room_wxid&quot;:&quot;xxxxxx&quot;, //微信群wxid &quot;room_nickname&quot;:&quot;xxxxxx&quot; //我在这个群里的昵称 } } - 退群: { &quot;task_type&quot;:8, &quot;task_dict&quot;: { &quot;room_wxid&quot;:&quot;xxxxxx&quot;, //要退出的微信群wxid } } - 上传文件 { &quot;task_type&quot;:9, &quot;task_dict&quot;: { &quot;file_index&quot;:&quot;xxxxxxx&quot;, //需要上传的文件的file_index } } //第三方需要将wehub上传的文件保存起来,建立file_index与上传文件的对应关系 - 发群公告 { &quot;task_type&quot;:10, &quot;task_dict&quot;: { &quot;room_wxid&quot;:&quot;xxxxxx&quot;, //微信群 &quot;msg&quot;:&quot;xxxxxx&quot; //群公告的内容 } } - 自动收账 (只能收取别人发给自己的转账) { &quot;task_type&quot;:11, &quot;task_dict&quot;: { &quot;wxid_from&quot;: &quot;xxxxxx&quot; //转账发起者wxid &quot;transferid&quot;:&quot;xxxxxx&quot; //transferid:自动收哪一笔转账 } } - 删除好友 { &quot;task_type&quot;:12, &quot;task_dict&quot;: { &quot;wxid_delete&quot;: &quot;xxxxx&quot; //要被删除的好友的wxid } } - 通过好友验证 { &quot;task_type&quot;:13, &quot;task_dict&quot;: { &quot;v1&quot;: &quot;xxxxx&quot;, &quot;v2&quot;: &quot;xxxxx&quot; } } - 重新上报联系人 (wehub会重新发送report_contact) { &quot;task_type&quot;:14, &quot;task_dict&quot;:{ &quot;flag_report_contact&quot;: xxxxx //0.4.9中新增,含义与login_ack中flag_report_contact含义相同 } } - 僵死粉检测 (检测结果通过report_zoom_check_status上报) { &quot;task_type&quot;:15 &quot;task_dict&quot;: { &quot;wxid&quot;:&quot;xxxxx&quot; //待检测的wxid } } - 获取指定wxid的详情(结果通过report_user_info上报) { &quot;task_type&quot;:16, &quot;task_dict&quot;: { &quot;wxid&quot;:&quot;xxxxx&quot; //要获取其详情的个人号的wxid } } - 创建群(新建群聊) { &quot;task_type&quot;:17, &quot;task_dict&quot;: { &quot;member_list&quot;:[&quot;xxxx&quot;,&quot;xxxx&quot;....] // member_list里面是要添加群聊的人员的微信id，如果不是微信id，可能添加失败 // member_list里不用包含自己的微信id(创建的群聊默认是包含当前微信id的) // 由于群聊必须至少3个人, 因此member_list里必须包含至少2个好友的wxid. } 注:每个微信号每天能创建的群是有上限的,无限制的创建群会带来封号风险,该任务只支持2.6.8.52及以上版本的微信. - 给群重命名 { &quot;task_type&quot;:18, &quot;task_dict&quot;: { &quot;room_wxid&quot;:&quot;xxxxx@chatroom&quot; //群的wxid &quot;room_name&quot;:&quot;xxxxx&quot; //新群名称 } } - 接受入群邀请 { &quot;task_type&quot;:19, &quot;task_dict&quot;: { &quot;invite_url&quot;:&quot;http://support.weixin.qq.com/xxxx&quot; //入群链接的地址 (该值从上报的入群链接消息的link_url字段中获取) } } 注:为安全起见,不要在短时间内接收多个群的邀请. - 操作标签(新增,删除标签) { &quot;task_type&quot;:100 &quot;task_dict&quot;: { &quot;tag_name&quot;:&quot;xxxxx&quot;, //被操作的标签名 &quot;wxid_list&quot;:[&quot;wxid_xxx&quot;,&quot;wxid_xxx&quot;] //群或者好友的wxid(不能包含陌生人) &quot;op_code&quot; : xx // 1:将wxid_list加入到tag_name标签中(如果没有这个标签则新建这个标签) // 2:将wxid_list中的成员从tag_name标签中删除 // 3:删除tag_name标签(此时会忽略wxid_list参数) } } - 重命名标签 (将old_tag_name标签重命名为new_tag_name) { &quot;task_type&quot;:101 &quot;task_dict&quot;: { &quot;old_tag_name&quot;: &quot;xxxx&quot;, &quot;new_tag_name&quot;:&quot;xxxx&quot; } } . 上报僵死粉检测结果(report_zoom_check_status) . 触发时机: 无论是操作客户端主动开始检测或者下发任务让客户端被动检测,都会上报检测到的结果. . request格式 { &quot;action&quot;:&quot;report_zoom_check_status&quot;, &quot;appid&quot;: &quot;xxxxxxx&quot;, &quot;wxid&quot;: &quot;xxxxxxx&quot;, &quot;data&quot;: { &quot;wxid&quot;:&quot;xxxxxx&quot;,//被检测的wxid &quot;result&quot;: x //0 :正常状态(不是僵尸粉) //1 :检测为僵尸粉(对方把我拉黑了) //2 :检测为僵尸粉(对方把我从他的好友列表中删除了) } } . respone格式为[common_ack格式] . pull_task(向回调接口请求一个任务) . wehub在appid验证通过以后,每间隔x秒请求一次(时间间隔可在wehub后台设置.若无需轮询,则设置任务轮询间隔 为0秒) request格式 . { &quot;action&quot;: &quot;pull_task&quot;, &quot;appid&quot;: &quot;xxxxxx&quot;, &quot;wxid&quot; : &quot;wxid_xxxxxxxx&quot;, &quot;data&quot;:{} } . respone格式 . { &quot;error_code&quot;: 0, &quot;error_reason&quot;: &quot;&quot;, &quot;ack_type&quot;:&quot;pull_task_ack&quot;, &quot;data&quot;: { //wehub通过task_id来识别不同的任务(task_id其值是由回调接口生成的字符串,请保证有唯一性) &quot;task_id&quot;: &quot;任务id&quot;, //字符串 &quot;task_data&quot;: $task //单个任务 } } . 注: $task是一个json对象,代表一个要下发给wehub执行的任务,格式见 [任务类型格式],wehub接收到任务以后,会立即开始执行,执行完成后会把结果异步地反馈给回调接口(通过report_task_result) . 示例 . 通过pull_task_ack 向wehub下发一个任务(该任务将wxid_abc从群bcdef@chatroom 中踢出) . { &quot;error_code&quot;: 0, &quot;error_reason&quot;: &quot;&quot;, &quot;ack_type&quot;:&quot;pull_task_ack&quot;, &quot;data&quot;: { &quot;task_id&quot;: &quot;aaaa111222&quot;, &quot;task_data&quot;: { &quot;task_type&quot;:2, &quot;task_dict&quot;: { &quot;room_wxid&quot;:&quot;bcdef@chatroom&quot;, &quot;wxid&quot;:&quot;wxid_abc&quot; } } } } . report_task_result(向回调接口反馈任务执行的结果) . request格式 . { &quot;action&quot;: &quot;report_task_result&quot;, &quot;appid&quot;: &quot;xxxxxxx&quot;, &quot;wxid&quot; : &quot;wxid_xxxxxxxx&quot; &quot;data&quot;: { &quot;task_id&quot;: &quot;任务id&quot;, &quot;task_result&quot;: 1, //0,任务执行失败,1任务执行成功 &quot;error_reason&quot;: &quot;&quot; //为什么执行失败,若任务执行成功则为空 } } . 任务执行成功只意味着wehub”调用了底层的相关接口向微信发送了数据”(wehub能做的也只能到这里). 但微信后台会对数据/(微信号的用户行为)做各种判断和过滤,若触发了微信的相关限制,最终的结果会是失败的(比如发送了一段含政治敏感的聊天文本,微信检测到了会拦截这则消息,对方会无法收到这则消息),这种行为的结果wehub是无法检测和无法影响到的. . respone格式为[common_ack格式] . report_user_info . 上报具体某个微信的详情 request格式 . { &quot;action&quot;:&quot;report_user_info&quot;, &quot;appid&quot;: &quot;xxxxxxx&quot;, &quot;wxid&quot; : &quot;wxid_xxxxxxxx&quot; &quot;data&quot;: { &quot;wxid&quot;: &quot;xxxxx&quot;, //wxid &quot;wx_alias&quot;: &quot;xxxxx&quot;, //有可能为空 &quot;nickname&quot;:&quot;xxxxx&quot;, //微信昵称 &quot;remark_name&quot; :&quot;xxxx&quot;, //好友备注 &quot;head_img&quot;:&quot;http://xxxxxxxx&quot; //头像的url地址(有可能获取不到为空) &quot;head_img_data&quot;:&quot;xxxxxxxxxx&quot; //头像的二进制数据(jpg格式)经过base64编码后的字符串 &quot;sex&quot; : xx , //性别:0未知,1 男， 2 女 &quot;country&quot;:&quot;xxx&quot;, //祖国(可能为空) &quot;province&quot;:&quot;xxxx&quot;, //省份(可能为空) &quot;city&quot;:&quot;xxxxx&quot; //城市(可能为空) &quot;is_friend&quot;: x //是否是我的好友,0:不是;1:是 &quot;room_list&quot;:[&quot;xx&quot;,&quot;xxx&quot;] //该微信号所在的群的列表 } } . 如果能获取到头像的url地址(head_img),则head_img_data为空 . 其他 . 容易混淆的地方 . wehub主动上报的消息与服务端下发的任务的区别 . (1).前者是在http request中(通过report_xxxxx),数据从wehub流向server;后者是在http respone中(通过common_ack 或者pull_task_ack),数据由服务端流向wehub . (2).二者的格式不样,前者的消息格式见[上报的消息单元的格式];后者的任务格式见 [任务类型格式] . 前者的消息主要是视觉可感知的数据(如文本,图片) ,而后者的任务除了发消息,还包括很多不可感知的事件(如踢人出群,删除好友等) . | common_ack 与 pull_task_ack 的区别: . common_ack中可携带多个下发的任务(data中有reply_task_list字段),但不会上报任务执行的结果 . pull_task_ack只能下发一个任务(data中没有reply_task_list字段),且必须有task_id字段,通过pull_task_ack 下发的任务会通report_task_result 上报任务执行的结果; . common_ack 与pull_task_ack中的任务格式都是一样的,见 [任务类型格式] . | . 关于websocket的通讯方式 . WeHub默认采用http短连接的方式和回调接口进行数据,这导致了回调接口只能被动的响应wehub,无法主动下发指令给WeHub.从0.4.2版本开始,WeHub支持用websocket的方式和第三方服务器进行通讯.具体流程如下: . wehub会先发送login request到当前回调地址,然后尝试从respone中寻找extension_protocol字段, 并获取到要去连接的websocket服务器的真实ws地址(格式为ws://xxxx或者wss://xxxx,和原有的http回调地址不一样). 这样做的好处是把目前的回调接口当做跳板,并且可以配置多个ws地址进行负载均衡. . 回调接口在收到wehub发送的login请求后返回如下(如果测试的话可以只对特定的wxid才返回这个ws地址) . { &quot;error_code&quot;: 0, &quot;error_reason&quot;: &quot;&quot;, &quot;ack_type&quot;:&quot;login_ack&quot;, &quot;data&quot;: { &quot;signature&quot;:&quot;xxxxxxxxxxx&quot; //返回给wehub客户端的签名(同上) &quot;extension_protocol&quot;: { &quot;type&quot;:&quot;websocket&quot;, //目前只能是&quot;websocket&quot; &quot;param&quot;: { &quot;ws_url&quot;:&quot;ws://127.0.0.1:3456/ws&quot;, //ws服务地址 &quot;heartbeat_interval&quot;:30 //心跳时间间隔(秒) } } } } . wehub获取到ws地址后,之后就会websocket服务进行连接,不再将数据post到原来回调接口地址上. websocket连接建立后wehub会主动定时发送心跳包给websocket服务器,时间间隔在heartbeat_interval字段中指定 websocket为什么需要心跳? 参考 https://blog.csdn.net/feiwutudou/article/details/80564630 . 心跳包格式如下 { &quot;atcion&quot;:&quot;heartbeat&quot;, &quot;appid&quot;: &quot;xxxxx&quot;, &quot;wxid&quot;: &quot;xxxx&quot;, &quot;data&quot;:{} } . 双方约定采用json格式的文本进行通讯,所有的数据格式仍然和目前已有的格式保持一致. 由于websocket连接的双方都可以收发数据,因此wehub不再需要定时发pull_task,websocket服务端可以主动发送common_ack, pull_task_ack格式的指令给wehub执行(json格式的文本) 关于websocket服务端的demo:https://github.com/fangqing/wehub-callback-websocket . 更多的问题请参考faq .",
    "url": "http://localhost:3333/main/dev.html",
    "relUrl": "/main/dev.html"
  }
  ,"3": {
    "title": "安装包下载",
    "content": "从0.4.0版本开始,wehub 支持在线更新. . 更新方式: 开启一个wehub客户端(此时最好不要登陆任何微信),点击右上角设置按钮–&gt;弹出菜单–&gt;检测更新,更新包下载完成之后会自动运安装. . 版本更新记录: . 2019.11.20: 发布 0.4.17: 最近win10的一次系统更新后,wehub被系统误认为是病毒,删除了核心的文件导致无法正常使用. 点击下载 . | 2019.11.12: 发布 0.4.16: 适配支持微信2.7.1.88 点击下载 . | 2019.10.25: 发布 0.4.14: bug fix,程序稳定性提升 点击下载 . | 2019.10.24: 发布 0.4.13: 增加对微信2.7.1.85版本的支持 (因为微信在今天又发布了新的版本) 修复0.4.12中上报的小程序消息中file_index字段为空的bug. . | 2019.10.23: 发布 0.4.12: 适配微信新版本,支持以下微信版本”2.6.8.51”,”2.6.8.52”,”2.6.8.65”,”2.6.8.68”,”2.7.1.65”,”2.7.1.74”,”2.7.1.78”,”2.7.1.82” 新增任务类型:接受入群邀请, 支持发送小程序 更新方式: 点击主界面右上角”齿轮”图标,在弹出的菜单中选择”检测更新” . | 2019.8.30: bug fix 点击下载 . | 2019.8.29: 发布0.4.9: 修复对微信2.7.0.64版本的适配问题 login_ack增加option字段以支持服务端自定义的设置 新增task_type为18的任务类型 . | 2019.8.15: 发布0.4.6: 增加对最新微信版本的支持. 支持2.6.4.56|2.6.5.38|2.6.6.28|2.6.7.40|2.6.7.57|2.6.8.51|2.6.8.52|2.6.8.65|2.6.8.68|2.7.0.64 版本的微信 新增两种任务类型(查询个人号详情,创建群) . | 2019.7.4: 发布0.4.5: fix some bug . | 2019.6.3: 发布0.4.4: 适配最新版本微信(2.6.8.51/2.6.8.52) 支持2.6.4.56|2.6.5.38|2.6.6.28 |2.6.7.40|2.6.7.57 |2.6.8.51|2.6.8.52 这几个版本的微信 . | 2019.4.4: 发布0.4.2: 支持2.6.4.56|2.6.5.38|2.6.6.28 |2.6.7.40|2.6.7.57 这几个版本的微信 (可通过0.4.0 或者0.4.1版本升级到该版本) wehub对websocket连接的支持(如何让wehub连接到第三方的websocket 服务 见文档中的详细描述.) websocket服务端/客户端的demo 新增两种任务类型(操作wehub本地的标签) 发消息@别人时’@’符号可放任意位置 . | 2019.3.18: 发布0.4.1: 适配微信2.6.7.57 版本(可通过0.4.0版本的更新功能升级到0.4.1) . | 2019.3.15: 发布0.4.0 :客户端强制做安全验证, 新增检测更新功能(下次升级可支持通过客户端进行升级). 添加对僵尸粉检测任务的支持. . | 2019.2.28: 发布0.3.13, 对0.3.12版本中适配出现的问题的进行修复 . | 2019.2.26: 发布0.3.12版本,适配支持微信最新的2.6.7.40版本 . | 2019.1.18: 发布0.3.8版本: 新增report_friend_removed (上报好友被删除的事件) . | 2018.12.27: 发布0.3.6版本: 增加缓存清理功能 . | 2018.12.11: 发布 0.3.3 版本:上报的文本消息中新增atuserlist字段;支持上传文件消息中的文件 . | 2018.11.30: 发布 0.3.0 版本 适配微信最近发布的新版本2.6.6.28( !!注意在2.6.5.38 和2.6.6.28 之间微信临时推出了2.6.6.25版本,我们没有适配和支持这个版本) . 支持消息中的语音上传 支持下发gif表情任务 report_contact 中增加公众号信息 . | 2018.11.16 发布 0.2.15版本: 适配微信最近发布的新版本2.6.5.38,同时修正了之前微信中的图片与视频在每天某时间段内(每天18:00之后)不自动下载的问题. . | 2018.10.23: 发布0.2.6,新增action “report_contact_update”,用于改进上报的联系人列表不全的问题. . | 208.10.17 发布0.2.3: login 中增加 “local_ip” 字段 . | 2018.10.12: 发布wehub 0.2.2, 增加了安全验证机制 . | . 回调接口必须实现对login的正确处理: 在接收到login request后必须有login_ack 返回,并且按照文档中规定的格式返回,否则wehub 会认为第三方回调接口没有正常开启而停止数据上报. . 2018.9.28: 发布wehub 0.2.0 | . 1.简化了ack中的协议 2.&quot;发消息任务&quot;的任务类型数据结构有调整: 调整前的数据结构为: { &quot;task_type&quot;: 1, &quot;task_dict&quot;: { &quot;room_wxid&quot;: &quot;xxxxxx&quot;, &quot;wxid&quot;:&quot;xxxxxxx&quot;, &quot;msg_list&quot;:[$push_msgunit,$push_msgunit,....] } } 调整后的数据结构为 { &quot;task_type&quot;: 1, &quot;task_dict&quot;: { &quot;wxid_to&quot;:&quot;xxxxxx&quot;, &quot;at_list&quot;:[&#39;xxxx&#39;,&#39;xxxx&#39;], &quot;msg_list&quot;:[$push_msgunit,$push_msgunit,....] } } 调整后发群消息时可以at多个微信号了(原来只能at一个微信号) .",
    "url": "http://localhost:3333/main/download.html",
    "relUrl": "/main/download.html"
  }
  ,"4": {
    "title": "常见问题",
    "content": "faq1.如何查看wehub与 回调接口之间的数据通讯? 方法1:安装fiddler,该软件可以很直接的观察到wehub 的所有的http通讯 在本机上开发和部署回调接口服务的开发者,需下载最新版wehub,打开设置界面,切换到”其他设置”–&gt; 设置http代理为127.0.0.1:8888(保持和fiddler默认的代理设置一致), 然后就可以在fiddler中查看wehub发送的http request和接收到的respone . | 方法2:Wehub在 C: Users xxxxxx AppData Roaming WeHub system log 目录下会产生log文件, log的配置文件为C: Users xxxxx AppData Roaming WeHub system cfg log4cxx.properties, 若要看很详细的log,请提高loglevel: 用记事本打开log配置文件,将第1行”log4j.rootLogger = DEBUG,logFile”中的”DEBUG” 修改为”TRACE”, 将第6行的”log4j.appender.logFile.Threshold = DEBUG”中的”DEBUG” 修改为”TRACE”,然后重启wehub. 之后log文件会详细记录wehub 发送出去的http request和回调接口返回的respone . log文件中记录的常见的错误列举 . 错误1:log中出现 “unknow format reply data,error = xxxxx” 原因: 回调接口收到wehub发送的http request后,返回的http respone不是json格式,wehub无法解析或解析出错 | 错误2:log中出现”HubLogic OnReplyError, replay error = xxx”, xxx的值是下方表格中的网络错误码 原因:回调接口的服务端运行不正常(比如服务没有开启,回调接口的域名无法解析等等) | . | . | . 网络错误码 Description . 1 | the remote server refused the connection (the server is not accepting requests) | . 2 | the remote server closed the connection prematurely, before the entire reply was received and processed | . 3 | the remote host name was not found (invalid hostname) | . 4 | the connection to the remote server timed out | . 5 | the operation was canceled before it was finished. | . 6 | the SSL/TLS handshake failed and the encrypted channel could not be established | . 7 | the connection was broken due to disconnection from the network, however the system has initiated roaming to another access point. The request should be resubmitted and will be processed as soon as the connection is re-established. | . 8 | the connection was broken due to disconnection from the network or failure to start the network. | . 9 | the background request is not currently allowed due to platform policy. | . 10 | while following redirects, the maximum limit was reached. | . 11 | while following redirects, the network access detected a redirect from a encrypted protocol (https) to an unencrypted one (http). | . 99 | an unknown network-related error was detected | . 101 | the connection to the proxy server was refused (the proxy server is not accepting requests) | . 102 | the proxy server closed the connection prematurely, before the entire reply was received and processed | . 103 | the proxy host name was not found (invalid proxy hostname) | . 104 | the connection to the proxy timed out or the proxy did not reply in time to the request sent | . 105 | the proxy requires authentication in order to honour the request but did not accept any credentials offered (if any) | . 199 | an unknown proxy-related error was detected | . 201 | the access to the remote content was denied (similar to HTTP error 403) | . 202 | the operation requested on the remote content is not permitted | . 203 | the remote content was not found at the server (similar to HTTP error 404) | . 204 | the remote server requires authentication to serve the content but the credentials provided were not accepted (if any) | . 205 | the request needed to be sent again, but this failed for example because the upload data could not be read a second time. | . 206 | the request could not be completed due to a conflict with the current state of the resource. | . 207 | the requested resource is no longer available at the server. | . 299 | an unknown error related to the remote content was detected | . 301 | the Network Access cannot honor the request because the protocol is not known | . 302 | the requested operation is invalid for this protocol | . 399 | a breakdown in protocol was detected (parsing error, invalid or unexpected responses, etc.) | . 401 | the server encountered an unexpected condition which prevented it from fulfilling the request. | . 402 | the server does not support the functionality required to fulfill the request. | . 403 | the server is unable to handle the request at this time. | . 499 | an unknown error related to the server response was detected | . faq2 wehub和回调接口的交互数据的编码方式 wehub 将utf-8编码的json格式的request以post方式发往回调接口(http 的ContentType 为application/json) 回调接口的respone也必须为utf-8的编码的json格式数据,否则wehub无法正确解析 . | faq3.为什么我的代码里按照你的文档里的json格式来写,下发的任务却没有执行? 请先检查你的代码逻辑是否正确,书写格式是否规范,执行起来是否按照预想的流程在走. 最最最重要的一点:你的代码执行到最后返回给wehub的json格式是否和文档中的一致, 注意你的代码中出现的各种trace,你的服务器可能会把这些trace全部返回给了wehub,请打开wehub的log, 看是否有异常(参考faq1) . | faq4.wehub是否可以多开? 0.1.4之前的wehub不支持多开微信,之后的wehub已支持多开微信,请升级到最新版的微信. 多开方式:先开启一个wehub和微信并登陆;再开启第二个wehub和微信并登陆;重复以上步骤 如果这个过程中wehub没有自动开启新的微信客户端,手动点击wehub界面上的&quot;打开微信&quot;按钮. . | . -.faq5 回调接口该如何处理上报的聊天消息? . wehub提供基础的微信聊天消息上报的能力,不会过滤发送者的wxid.因此回调接口在做自动回复的时候,需要过滤自己的微信号发的消息. 避免陷入&#39;回调接口下发自动 回复内容—&gt;wehub发消息—&gt;微信消息事件回调—&gt;wehub上报刚才自己发的消息—&gt;回调接口又下发聊天任务&#39;的死循环 如何过滤自己发的消息? - 若使用的wehub版本&lt;0.1.4,回调接口在收到report_new_msg时,判断msg中的wxid是否为这个wehub上登陆的wxid.若是,则不要下发task_type=1的发消息的任务 - 若使用的wehub版本&gt;=0.1.4,回调接口在收到report_new_msg时,判断msg中的wxid_from是否为这个wehub上登陆的wxid.若是,则不要下发task_type=1的发消息的任务 . faq6.为什么有时候wehub无法监测到微信? 1. 确定当前wehub 支持的微信版本号 方法: 打开wehub的安装目录,进入WeChatVersion 子目录,会发现有以微信版本号命名的子文件夹如2.6.xx.xx等等, 他们分别代表着wehub所支持的微信的版本号. 若你当前正在使用的微信的版本号不在上述之列,则表示你当前使用的wehub无法支持你当前运行的微信版本, 请下载安装最新版的WeHub.目前最新的WeHub(0.3.3)支持2.6.4.56|2.6.5.38|2.6.6.28 等3个版本的微信. 注意:360等安全软件可能会把wehub当成不安全的进程,从而误删除WeChatVersion目录下的文件, 请使用wehub时退出360进程或将wehub加入到360的信任名单.(很重要,很重要,很重要) 2. 看系统中是否有僵死的微信进程 打开系统的任务管理器,对所有的进程按&quot;名称&quot; 排序查看,查看当前有多少个微信进程. 只有名称为Wechat的进程才是微信进程,其他的如WeChatweb, WeChatStore都不是微信的主进程, 同时查看你的任务栏里有多少个微信的聊天或登陆窗口. 比如你的任务管理器中显示有4个&quot;Wechat&quot;进程 而在任务栏上你只看到了3个微信的窗口,说明有一个微信进程是僵死的. 若出现这种情况,请杀掉所有的微信进程,然后重新开启wehub登陆微信 3. 看系统是否安装了360等安全软件,或者其他的类似于wehub的微信辅助软件. 360会干扰wehub的正常的行为甚至会删除wehub的某些关键dll文件,其他的微信辅软件可能会和wehub冲突. 请彻底卸载掉这些软件(保险起见,最好重新安装wehub) . | faq7.为什么有时候wehub发图片很慢很慢? 目前已知的情况是,运行在阿里云主机上的wehub发图片很慢很慢(猜测可能微信对运行阿里云的微信客户端有某些特殊的行为处理), 更换成腾讯云的主机后一切都正常了 . | faq8.为什么wehub 开启后,appid无法验证成功? appid验证失败后会弹出设置界面,并用红色文字标识失败的原因. 一般 appid验证失败有两种情况: 1.appid 过期了需要续费, 这种情况请在微信群里资讯我们的工作人员 2.wehub 发给回调接口的 login 请求没有正确地返回: 可能你的网络问题,可能你的服务器没有正常启动(看wehub的log). 若开启了安全验证,回调接口在处理logIn时可能没有正确地返回签名. . | faq9:我在服务端代码里打了log,登陆后为什么没有收到 report_contact? report_contact每次post的数据量会比较大(好友/群越多,post的数据就越大),请将服务端能接受的post_max_size 调整成至少10M. 由于很多服务器比如ngix 默认的接收的最大量会比较小(比如1M),当report_contact的数据量超过这个上限时,服务端会无法接收这个request. 请参考这个网页:https://www.jianshu.com/p/7797b200e1f4 . | faq10: 关于下发的任务中的字段的数据类型 task_id字段 必须为字符串 error_code,task_typ,msg_type字段必须为数字 . | faq11: 设置界面的”代理”是做什么的? 如果设置了这个代理,wehub会采用这个代理设置进行网络数据的上报. . | faq12:为什么会出现 99 错误? 如果设置界面中弹出&quot;网络错误(99)&quot;,首先检查你本地的网络连接是否正常,其次检查你回调接口的服务是否正常运行(比如你的服务可能已经crash了) 另外一种极端情况是socket句柄被消耗殆尽了,出现这种情况的原因是服务端在收到wehub发送的request后没有resopone. wehub与回调接口的通讯是通过http进行的(目前设置的http超时时间为30秒),而一个网络连接是需要消耗一个socket句柄的(一种系统资源). wehub向回调接口发送一个http request后,如果回调接口不处理这个request(比如发现这个action不是自己所关心的事件所以没有处理), 那么wehub必须等待这个http链接30秒超时后才能回收这个socket句柄.在群比较多,群内聊天比较频繁的情况下,会不断地消耗socket句柄. 如果服务端不即时响应这些request,会导致消耗的socket句柄无法及时回收,最终导致系统socket句柄被消耗殆尽而出现99的网络错误. 因此如果服务端对wehub reqeust的action不感兴趣,也必须给出reply(可以简单回复一个空的json) . | . 新发现的问题记录: 2019.9.25:发现”赛门铁克”会拦截wehub的网络请求,导致wehub无法验证. .",
    "url": "http://localhost:3333/main/faq.html",
    "relUrl": "/main/faq.html"
  }
  ,"5": {
    "title": "关于WeHub",
    "content": "什么是WeHub? . WeHub是一款针对微信windows客户端的辅助工具,它能监测微信中的各种事件/数据(比如好友信息,群信息), 并辅助微信执行各种操作(如发消息);同时提供了对接企业服务的能力(这需要第三方开发一套符合WeHub数据应答 格式的webserver接口,以下简称为回调接口). . | 目前WeHub与回调接口之间的通讯方式支持http和websocket,双方约定用采用json格式,utf-8编码的数据进行通讯 | WeHub不提供sdk方式的二次开发接口,在WeHub客户端中,已经集成了很多已经开发好的通用的功能模块(比如群发,客服,关键词拉群等等). | . 微信-wehub-回调接口 三者之间的数据流 . . 我该用WeHub还是WeTool? . WeHub与WeTool 是不同的产品,二者的区别如下 . 软件名 接口能力 已有的插件功能 是否收费 技术支持 . WeTool免费版 | 无 | 有一些通用的基础插件 | 不收费 | 无 | . WeTool企业版 | 无 | 插件更丰富强大,有很多wehub没有的插件比如 SOP,素材库等等 | 收费 | 有 | . WeHub | 有 | 具备wetool免费版已有的插件功能 | 收费 | 有 | . 如果你需要获取微信中的数据,目前只能通过WeHub的回调接口方式来获取,并且第三方需要进行相关后台功能的开发, 反之请用WeTool企业版. . WeHub能监测到微信内部的相关事件 . 这些事件包括: . 微信登陆事件(login) | 微信登出事件(logout) | 好友列表和群列表的信息及更新(report_contact,report_contact_update) | 收到新消息,包含私聊消息和群聊消息(report_new_msg) | 群成员的变化(report_room_member_change) | 发现新的群(report_new_room) | 收到新的加好友请求(report_friend_add_request) | 好友被删除(report_friend_removed) | 新的好友(report_new_friend) | WeHub能执行回调接口下发相关的指令 . 这些指令包括: . 发送一条具体的消息(包括文字,发送图片,动态表情,文件,发送链接,发送视频,发送个人名片) | 踢人出群 | 向好友发送入群邀请/拉好友入群 | 获取群成员信息 | 加群成员为好友 | 修改好友备注 | 修改群昵称(修改当前微信号在某个群里的群昵称) | 退群(退出某个群) | 发送群公告 | 自动收账(自动收取其他微信号对当前微信号的某笔转账) | 删除某个好友 | 通过好友验证(当其他账号给当前微信号发送加好友请求时,同意这次请求) | 上报当前好友列表和群列表 | 检测某个微信号是否是僵尸好友 | 上传文件:上传某条聊天信息中的图片/语音/视频 | 上报指定好友的详情 | 建群 | 修改群名称 | 接收入群邀请 | WeHub不能做什么? . WeHub是基于PC版微信的功能而开发的,因此PC版微信本身不具备的功能,WeHub也都不支持(如发朋友圈,发语音等行为都不支持). | WeHub也局限于微信的各种规则限制,因此如果WeHub使用者的行为触犯微信的各种约束条款时,其所登陆的微信号一样会被封禁。 因此使用者不能无节制地滥用WeHub,WeHub只是一个提供些许便利的工具软件,无法保证你的微信不被封号. 是否封号取决于你使用工具做了什么(微信后台后分析和记录你的行为特征),当你无节制地滥用工具时,封号将是不可避免的. 请心怀敬畏,用合适的工具做合适的事 . | 杀毒软件会对wehub 的正常运行构成影响,导致各种崩溃问题(请保证运行wehub的系统上没有360,卡巴斯基,麦咖啡等等软件, 或至少将wehub主进程加入这些软件的白名单里) | . 使用WeHub的客户有哪些? . 目前使用WeHub的客户覆盖:自媒体、互联网营销、在线教育,家政,金融财税证券保险以及某些一线互联网公司(如腾讯,爱奇艺等) . 相关的Demo . 对接的demo,php版 对接的demo,java版 对接的demo,python版 这些demo的核心都是构建http server服务,处理wehub发送的http request 并且返回相应的http respone .",
    "url": "http://localhost:3333/index.html",
    "relUrl": "/index.html"
  }
  ,"6": {
    "title": "常见的误区",
    "content": "服务端对接过程中遇到的常见的错误 . 常见的错误情况有: . 通过common_ack下发的指令格式和pull_task_ack下发的指令格式不一样.开发人员混淆了二者的数据格式, 错误地通过common_ack下发了pull_task_ack的任务格式的数据或反之. | 漏了某个字段, 比如通过pull_task_ack下发的任务需要 task_id字段,但指令中漏了这个字段. | 文档中规定task_id字段的值应该为字符串,但指令中返回的却是纯数字. | 将本来应该下发给微信A的指令错误地下发给里微信B,从而获取不到期望的数据 | 一个群里有两个自家的机器人,服务端没有处理好二者的逻辑关系,导致两个机器人打架 | 收到了wehub发的http request,但是回调接口没有(及时)返回http respone. 可能的危害见Faq12 | 在一次respone中返回大量的任务 | 服务端不建立缓存,所有的数据全部依赖于wehub登录后的上报 | 服务端没有trace应对机制,当服务端出现trace时还茫然不知,错误地以为把指令成功下发给了WeHub(其实wehub没收到指令) | 高频率的下发需要与微信进行交互的指令:比如发消息,建群等等(这会增加封号风险) | . 其他问题见Faq .",
    "url": "http://localhost:3333/main/misunderstanding.html",
    "relUrl": "/main/misunderstanding.html"
  }
  ,"7": {
    "title": "相关通知",
    "content": "相关通知 . Nov 27, 2019 Win10环境下被误当成病毒的解决方案 . | Nov 27, 2019 如何将wehub加入到安全软件的白名单中 . | .",
    "url": "http://localhost:3333/post/notify.html",
    "relUrl": "/post/notify.html"
  }
  
}